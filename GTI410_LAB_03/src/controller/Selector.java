/*
   This file is part of j2dcg.
   j2dcg is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.
   j2dcg is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   You should have received a copy of the GNU General Public License
   along with j2dcg; if not, write to the Free Software
   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

package controller;

import model.*;
import view.Application;

import java.awt.Point;
import java.awt.event.*;
import java.awt.geom.NoninvertibleTransformException;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;

/**
 * <p>Title: Selector</p>
 * <p>Description: Class that selects a single shape</p>
 * <p>Copyright: Copyright (c) 2003 Mohammed Elghaouat, Eric Paquette</p>
 * <p>Company: (ÉTS) - École de Technologie Supérieure</p>
 * @author unascribed
 * @version $Revision: 1.12 $
 */
public class Selector extends AbstractTransformer {
	/**
	 * Default constructor
	 */
	public Selector() {
	}

	 /**
	  * Get the 
	  * @return Selector ID
	  */
	public int getID(){
		return idSelector;
	}

	/**
	 * Mouse pressed event management method
	 * @param e mouse event generated by the system
	 */
	protected boolean mousePressed(MouseEvent e){
		int i = 0;
		Shape shape;
		Document doc = Application.getInstance().getActiveDocument();
		doc.clearSelectedObjectList();
		doc.makeSelectionRectangle();
		selectionOrigine.setLocation(e.getX(),e.getY());

		List intersectedObjects = getDocumentObjectsAtLocation(e.getPoint());
		if (!intersectedObjects.isEmpty()) {
			doc.addSelectedObject((Shape)intersectedObjects.get(0));
			return true;
		}
		
		return true;
	}

	/**
	 * Mouse released event management method
	 * @param e mouse event generated by the system
	 */
	protected boolean mouseReleased(MouseEvent e) {
		Shape shape;
		Document doc = Application.getInstance().getActiveDocument();
		List intersectedObjects = getDocumentObjectsAtLocation(e.getPoint());
		doc.clearSelectedObjectList();
		if (!intersectedObjects.isEmpty()) {
			doc.addSelectedObject((Shape)intersectedObjects.get(0));
		}
		doc.notifyDocChanged();
		return true;
	}

	static public List getDocumentObjectsAtLocation(Point p) {	
		Document doc = Application.getInstance().getActiveDocument();
		List allObjects = doc.getDocumentObjects();
		List intersectedObjects = new LinkedList();
		getObjectsAtLocation(allObjects, p, intersectedObjects);
		return intersectedObjects;
	}
	
	static public List getObjectsAtLocation(List objects, Point p, List intersectedObjects) {
		Shape shape;

		ListIterator iter = objects.listIterator(objects.size());

		while (iter.hasPrevious()) {
			shape = (Shape)iter.previous();
			if (shape instanceof ShapeContainer) {
				// Transform the point to the Container space.
				Point transformedPt = new Point();
				try {
					shape.inverseTransformPoint(p, transformedPt);
				} catch (NoninvertibleTransformException e) {
					e.printStackTrace();
					continue;
				}
				getObjectsAtLocation(((ShapeContainer)shape).getShapes(), 
									 transformedPt, intersectedObjects);
			}
			if (shape.isThisPointIn(p)) {
				intersectedObjects.add(shape);
			}
		}
		
		return intersectedObjects;
	}
}